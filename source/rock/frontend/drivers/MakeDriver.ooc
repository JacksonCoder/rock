import io/[File, FileWriter], text/Buffer

import structs/[List, ArrayList]
import ../[BuildParams, Target]
import ../compilers/AbstractCompiler
import ../../middle/Module
import Driver, SequenceDriver

MakeDriver: class extends SequenceDriver {

    builddir, makefile, originalOutPath: File

    init: func (.params) { super(params) }
    
    setup: func {
        // build/
        builddir = File new("build")
        
        // build/rock_tmp/
        originalOutPath = params outPath
        params outPath = File new(builddir, params outPath getPath())
        params outPath mkdirs()
        
        // build/Makefile
        makefile = File new(builddir, "Makefile")
    }

	compile: func (module: Module) -> Int {
        
        if(params verbose) {
           "Make driver" println()
        }
        
        printf("Writing to %s\n", makefile path)
        fW := FileWriter new(makefile)
        
        fW write("# Makefile generated by rock, the ooc compiler written in ooc\n\n")
        fW write("CC=%s\n" format(params compiler executablePath))
        
        fW write("# try to determine the OS and architecture\n")
        fW write("OS := $(shell uname -s)\n")
        fW write("MACHINE := $(shell uname -m)\n")
        fW write("ifeq ($(OS), Linux)\n")
        fW write("    ARCH=linux\n")
        fW write("else ifeq ($(OS), Darwin)\n")
        fW write("    ARCH=osx\n")
        fW write("else ifeq ($(OS), CYGWIN_NT-5.1)\n")
        fW write("    ARCH=win\n")
        fW write("else ifeq ($(OS), MINGW32_NT-5.1)\n")
        fW write("    ARCH=win\n")
        fW write("else\n")
        fW write("    $(shell echo \"OS ${OS} doesn't have pre-built Boehm GC packages. Please compile and install your own and recompile with GC_PATH=-lgc\")\n")
        fW write("endif\n")
        
        fW write("ifneq ($(ARCH), osx)\n")
        fW write("  ifeq ($(MACHINE), x86_64)\n")
        fW write("    ARCH:=${ARCH}64\n")
        fW write("  else\n")
        fW write("    ARCH:=${ARCH}32\n")
        fW write("  endif\n")
        fW write("endif\n")
        
        fW write("# this folder must contains libs/\n")
        fW write("ROCK_DIST?=.\n")
        
        fW write("# uncomment to link dynamically with the gc instead (e.g. -lgc)\n")
        fW write("#GC_PATH?=-lgc\n")
        fW write("GC_PATH?=${ROCK_DIST}/libs/${ARCH}/libgc.a\n")
        
        fW write("CFLAGS+=-I %s" format(originalOutPath getPath()))
        fW write(" -I ${ROCK_DIST}/libs/headers/")
        
        if(params debug) {
            fW write(" -g")
        }
        
        params compiler reset()
        iter := params compiler command iterator()
        iter next()
        while(iter hasNext()) {
            fW write(" "). write(iter next())
        }
        
        for(define in params defines) {
            fW write(" -D"). write(define)
        }
        
        for(compilerArg in params compilerArgs) {
            fW write(" "). write(compilerArg)
        }
        
        for(incPath in params incPath getPaths()) {
            fW write(" -I "). write(incPath getPath())
        }
        
        fW write("\n")
        
        fW write("EXECUTABLE=")
        if(params binaryPath != "") {
            fW write(params binaryPath)
        } else {
            fW write(module simpleName)
        }
        fW write("\n")
        
        fW write("OBJECT_FILES:=")
        
        toCompile := collectDeps(module, ArrayList<Module> new(), ArrayList<String> new())
        
        for(currentModule in toCompile) {
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            fW write(path). write(".o ")
        }
        
        fW write("\n\n.PHONY: compile link\n\n")
        
        fW write("all: compile link\n\n")
        
        fW write("compile: ${OBJECT_FILES}")
        
        fW write("\n\t@echo \"Finished compiling for arch ${ARCH}\"\n")
        
        fW write("\n\n")
        
        oPaths := ArrayList<String> new()
        
        for(currentModule in toCompile) {
            path := File new(originalOutPath, currentModule getPath("")) getPath()
            oPath := path + ".o"  
            cPath := path + ".c"    
            oPaths add(oPath)
            
            fW write(oPath). write(": ").
               write(cPath). write(" ").
               write(path). write(".h ").
               write(path). write("-fwd.h\n")
            
            fW write("\t${CC} ${CFLAGS} -c %s -o %s\n" format(cPath, oPath))
        }
        
        fW write("\nlink: ${OBJECT_FILES}\n")
        
        fW write("\t${CC} ${CFLAGS} ${OBJECT_FILES} ")
        
        for(dynamicLib in params dynamicLibs) {
            fW write(" -l "). write(dynamicLib)
        }
        
        for(additional in params additionals) {
            fW write(" "). write(additional)
        }
    
        for(libPath in params libPath getPaths()) {
            fW write(" -L "). write(libPath getPath())
        }
        
        fW write(" -o ${EXECUTABLE}")
        
        libs := getFlagsFromUse(module)
        for(lib in libs) {
            fW write(" "). write(lib)
        }
        
        if(params enableGC) {
            fW write(" -lpthread ")
            if(params dynGC) {
                fW write("-lgc")
            } else {
                arch := params arch equals("") ? Target getArch() : params arch
                Target toString(arch)
                fW write(" ${GC_PATH}")
            }
        }
        
        fW write("\n\n")
        
        fW close()
        
        /*
		copyLocalHeaders(module, params, ArrayList<Module> new())    
		
		for(currentModule in toCompile) {
            
            initCompiler(params compiler)    
            params compiler setCompileOnly()
            
            path := File new(params outPath, currentModule getPath("")) getPath()
            oPath := path + ".o"    
            cPath := path + ".c"    
            oPaths add(oPath)
            
            cFile := File new(cPath)
            oFile := File new(oPath)
            
            if(cFile lastModified() > oFile lastModified()) {
                
                params compiler addObjectFile(cPath)    
                params compiler setOutputPath(oPath)    
                
                params compiler addIncludePath(File new(params distLocation, "libs/headers/") getPath())
                params compiler addIncludePath(params outPath getPath())
                        
                for(define in params defines) {
                    params compiler defineSymbol(define)
                }
                for(dynamicLib in params dynamicLibs) {
                    params compiler addDynamicLibrary(dynamicLib)
                }
                for(compilerArg in params compilerArgs) {
                    params compiler addObjectFile(compilerArg)
                }
                for(incPath in params incPath getPaths()) {
                    params compiler addIncludePath(incPath getAbsolutePath())
                }
                
                
                //if(params fatArchitectures != null) {
                //    params compiler setFatArchitectures(params fatArchitectures)    
                //}
                //if(params osxSDKAndDeploymentTarget != null) {
                //    params compiler setOSXSDKAndDeploymentTarget(params osxSDKAndDeploymentTarget)    
                //}

                libs := getFlagsFromUse(module)
                for(lib in libs) {
                    //printf("[SequenceDriver] Adding lib %s from use\n", lib)
                    params compiler addObjectFile(lib)
                }
                
                if(params verbose) params compiler getCommandLine() println()
                
                //long tt1 = System.nanoTime()    
                code := params compiler launch()    
                //long tt2 = System.nanoTime()    
                //if(params timing) System.out.println("  (" + ((tt2 - tt1) / 1000000)+")")    
                    
                if(code != 0) {
                    fprintf(stderr, "C compiler failed, aborting compilation process\n")
                    return code 
                }
                
            } else {
                
                if(params veryVerbose) {
                    ("Skipping "+cPath+", just the same.") println()
                }
                
            }
		}    
		
		if(params link) {
			
			initCompiler(params compiler)    
			if(params linker != null) params compiler setExecutable(params linker)    
			
			for(oPath in oPaths) {
				params compiler addObjectFile(oPath)    
			}
			
            for(define in params defines) {
                params compiler defineSymbol(define)
            }
            for(dynamicLib in params dynamicLibs) {
                params compiler addDynamicLibrary(dynamicLib)
            }
            for(additional in additionals) {
                params compiler addObjectFile(additional)
            }
		
			for(libPath in params libPath getPaths()) {
				params compiler addLibraryPath(libPath getAbsolutePath())    
			}
			
			//if(params fatArchitectures != null) {
			//	params compiler setFatArchitectures(params fatArchitectures)    
			//}
			//if(params osxSDKAndDeploymentTarget != null) {
			//	params compiler setOSXSDKAndDeploymentTarget(params osxSDKAndDeploymentTarget)    
			//}

			if(params binaryPath != "") {
                params compiler setOutputPath(params binaryPath)
            } else {
                params compiler setOutputPath(module simpleName)
            }
            
            libs := getFlagsFromUse(module)
            for(lib in libs) {
                //printf("[SequenceDriver] Adding lib %s from use\n", lib)
                params compiler addObjectFile(lib)
            }
			
			if(params enableGC) {
                params compiler addDynamicLibrary("pthread")
                if(params dynGC) {
                    params compiler addDynamicLibrary("gc")
                } else {
                    arch := params arch equals("") ? Target getArch() : params arch
                    libPath := "libs/" + Target toString(arch) + "/libgc.a"
                    params compiler addObjectFile(File new(params distLocation, libPath) path)
                }
            }
			if(params verbose) params compiler getCommandLine() println()
	
			//long tt1 = System.nanoTime()    
			code := params compiler launch()    
			//long tt2 = System.nanoTime()    
			//if(params timing) System.out.println("  (linking " + ((tt2 - tt1) / 1000000)+"ms)")    
			//if(params timing) System.out.println("(total " + ((System.nanoTime() - tt0) / 1000000)+"ms)")    
			
			if(code != 0) {
                fprintf(stderr, "C compiler failed, aborting compilation process\n")
				return code
			}
		
		}
		
		if(params outlib != null) {
			
			// TODO: make this platform-independant (for now it's a linux-friendly hack)
            args := ArrayList<String> new()
			args add("ar")      // ar = archive tool
			args add("rcs")     // r = insert files, c = create archive, s = create/update .o file index
			args add(params outlib)    
			
			allModules := collectDeps(module, ArrayList<Module> new(), ArrayList<String> new())    
			for(dep in allModules) {
				args add(File new(params outPath, dep getPath("")) getPath() + ".o")    
			}
			
			if(params verbose) {
                command := Buffer new()
                for(arg in args) {
					command append(arg) .append(" ")
				}
                command toString() println()
			}
			
            process := Process new(args)
            process getOutput() println() // not ideal, should redirect to stdin+stdout instead
			
		}
        */
		
		return 0    
		
	}
	
}
