%{
#include <stdio.h>

/* ooc/rock imports */
#include <sdk/lang/BasicTypes-fwd.h>
#include <sdk/io/FileReader.h>

#include <source/rock/frontend/CommandLine-fwd.h>
#include <source/rock/middle/Parenthesis-fwd.h>
#include <source/rock/middle/Type-fwd.h>
#include <source/rock/middle/Line-fwd.h>
#include <source/rock/middle/Node-fwd.h>
#include <source/rock/middle/StringLiteral-fwd.h>
#include <source/rock/middle/VariableAccess-fwd.h>
#include <source/rock/middle/IntLiteral-fwd.h>
#include <source/rock/middle/BinaryOp.h> // tight dependency: we use static members
#include <source/rock/middle/FunctionCall-fwd.h>
#include <source/rock/middle/FunctionDecl-fwd.h>
#include <source/rock/middle/CoverDecl-fwd.h>

#define YYSTYPE struct _rock_middle__Node*

typedef char *String;
typedef struct _lang__Object *Object;
typedef struct _rock_middle__Node *Node;
typedef struct _rock_middle__Type *Type;
typedef struct _rock_middle__Statement *Statement;
typedef struct _rock_middle__CoverDecl *CoverDecl;
typedef struct _rock_middle__ClassDecl *ClassDecl;
typedef struct _rock_middle__Expression *Expression;
typedef struct _rock_middle__OpTypesClass *OpTypesClass;

// uncomment to enable leg's finicky debug output
//#define YY_DEBUG 1

/* Current line number */
static int yylineno;

/* Path of the file we're parsing. */
static char* path;
 
/* The stream we're reading from. */
static struct _io__FileReader *stream;

/* Send input to yyparse from codebuf instead of stdin */
#define YY_INPUT(buf, result, max_size) {        \
    result = FileReader_read(stream, buf, 0, max_size);     \
    static int doneNewlineHack = 0;              \
    if(result == 0 && doneNewlineHack == 0) {    \
        doneNewlineHack = 1;                     \
        char last = buf[strlen(buf) - 1];        \
        if(last != '\n') {                       \
            (*buf) = '\n';                       \
            result = 1;                          \
        }                                        \
    }                                            \
}

%}

Stmt    = WS d:Decl EOL
        | WS e:Expr EOL
        | WS ( !EOL . )* EOL {
            printf("error at line %d: unexpected input '%s'\n", yylineno, yytext);
            exit(1);
        }

Expr    = Assignment
        | VariableDecl
        | FunctionCall
        | Sum
        | WS Comment WS Expr
        
#######################################################################
        
Decl  =  (TypeDecl | FunctionDecl | VariableDecl)

#######################################################################
                   
FunctionDecl = 
    IDENT {
        $$=(Node) FunctionDecl_new_funcDecl(String_clone(yytext), nullToken);
        stack_push($$);
    }
    COLON "func" -
    Body? 
    - {
        $$=(Node) stack_pop(FunctionDecl_class())
    }

#######################################################################
    
Body = 
    OPEN_BRACK
    WS
    Line*
    WS
    CLOS_BRACK -

#######################################################################

Line  = (WS !EOL e:Expr EOL WS) {
            stack_add((Node) Line_new_line((Statement) $$));
        }
        | Comment

#######################################################################
    
TypeDecl = (CoverDecl | ClassDecl)
    
#######################################################################
   
TypeDeclBody = (
        WS fDecl:FunctionDecl { stack_add(fDecl); }
      | WS vDecl:VariableDecl { stack_add(vDecl); }
      | WS Comment
    )*
    WS

#######################################################################
    
CoverDecl = (FromCoverDecl)
    
FromCoverDecl =
    IDENT {
        stack_push((Node) CoverDecl_new_coverDecl(String_clone(yytext), NULL, nullToken))
    } -
    COLON "cover" - "from" - t:Type { CoverDecl_setFromType((CoverDecl) stack_peek(), (Type) t); }
    - EOL - {
        stack_pop(CoverDecl_class())
    }

#######################################################################

ClassDecl = 
    IDENT {
        stack_push((Node) ClassDecl_new_classDecl(String_clone(yytext), NULL, nullToken))
    } -
    COLON "class"
    - OPEN_BRACK
    TypeDeclBody?
    WS CLOS_BRACK - {
        stack_pop(ClassDecl_class())
    }
    
#######################################################################

Comment = (CommentLine | CommentMultiLine)
CommentLine = "//" (!EOL .)* EOL
CommentMultiLine = "/*" (!"*/" .)* "*/"

#######################################################################

VariableDecl =
    name:IDENT -
    COLON -
    type:Type - {
        $$=(Node) VariableDecl_new_vDecl((Type) type, (String) name, nullToken);
    }
    
#######################################################################
    
Type = IDENT { $$=(Node) BaseType_new_baseType(String_clone(yytext), nullToken) }

#######################################################################

Assignment =
    l:VariableAccess
    ASSIGN
    r:Expr
    - {
        printf("Parsed an assignment, l is a %s\n", ((Object) l)->class->name);
        $$=(Node) BinaryOp_new_binaryOp((Expression) l, (Expression) r, ((OpTypesClass) OpTypes_class())->ass, nullToken);
    }
    
#######################################################################
    
VariableAccess =
    IDENT { $$=(Node) VariableAccess_new_variableAccess(String_clone(yytext), nullToken); }
    (- IDENT { printf("Got member access! %s\n", yytext); })*

#######################################################################

FunctionCall = 
    IDENT {
        stack_push((Node) FunctionCall_new_funcCall(String_clone(yytext), nullToken));
    }
    OPEN_PAREN
    ExpressionList?
    CLOS_PAREN
    - {
        $$= (Node) stack_pop(FunctionCall_class());
    }

ExpressionList  =  Expr        { stack_add($$) }
                   (COMMA Expr { stack_add($$) })*

Sum     = l:Product
                ( PLUS  r:Product {
                    $$=(Node) BinaryOp_new_binaryOp((Expression) l, (Expression) r,
                        ((OpTypesClass) OpTypes_class())->add, nullToken);
                }
                | MINUS r:Product {
                    $$=(Node) BinaryOp_new_binaryOp((Expression) l, (Expression) r,
                        ((OpTypesClass) OpTypes_class())->sub, nullToken);
                }
                )*

Product = l:Value
                ( TIMES  r:Value {
                    $$=(Node) BinaryOp_new_binaryOp((Expression) l, (Expression) r,
                        ((OpTypesClass) OpTypes_class())->mul, nullToken);
                }
                | DIV r:Value {
                    $$=(Node) BinaryOp_new_binaryOp((Expression) l, (Expression) r,
                        ((OpTypesClass) OpTypes_class())->div, nullToken);
                }
                )*

Value   = i:NUMBER
        | i:STRING_LIT
        | VariableAccess !ASSIGN
        | OPEN_PAREN inner:Expr CLOS_PAREN {
            $$=(Node) Parenthesis_new_parenthesis((Expression) inner, nullToken)
        }
        
NUMBER       = < [0-9]+ >                      - { $$=(Node) IntLiteral_new_intLiteral(atoll(yytext), nullToken); }
STRING_LIT   = '"' < (!'"' .)* > '"'           - { $$=(Node) StringLiteral_new_stringLiteral(String_clone(yytext), nullToken); }
IDENT        = < [a-zA-Z_]([a-zA-Z0-9_])* >    - { $$=(Node) String_clone(yytext) }
COLON        = ':'           -
COMMA        = ','           -
ASSIGN       = '='           -
PLUS         = '+'           -
MINUS        = '-'           -
TIMES        = '*'           -
DIV          = '/'           -
OPEN_PAREN   = '('           -
CLOS_PAREN   = ')'           -
OPEN_BRACK   = '{'           -
CLOS_BRACK   = '}'           -

-       = [ \t]*
EOL     = ('\n' | '\r\n' | '\r') { yylineno++ } | ';'
WS      = ([ \t] | EOL)*

%%

int Parser_parse(char *pathArg) {
    /* Parse code */
    path = pathArg;
    stream = FileReader_new_withName(path);
    yylineno = 0;
    while (yyparse()) {}
    return 0;
}
