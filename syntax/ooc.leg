%{
#include <stdio.h>
#include <source/rock/middle/Node-fwd.h>
#include <source/rock/middle/StringLiteral-fwd.h>
#include <source/rock/middle/FunctionDecl-fwd.h>
#include <source/rock/middle/FunctionCall-fwd.h>

void stack_push(struct _rock_middle__Node *node);
void stack_pop(struct _rock_middle__Node *node);
%}

Stmt    = WS e:Expr EOL
        | WS d:Decl EOL
        | ( !EOL . )* EOL               { printf("error\n"); }

Expr    = i:IDENT ASSIGN s:Sum
        | f:FunctionCall
        | s:Sum
        
Decl            =  FunctionDecl
                   
FunctionDecl    =  IDENT {
                    printf("<functionDecl '%s'>\n", yytext);
                    stack_push(FunctionDecl_new_funcDecl(yytext, nullToken));
                }
                   COLON "func" - Body?  { printf("</functionDecl>\n") } -

Body            =  OPEN_BRACK { printf("<body>\n") }
                   EOL*
                   Line*
                   CLOS_BRACK { printf("</body>\n") } -
                   
Line            =  (WS !EOL Expr EOL*) { printf("</line>\n") }

FunctionCall    =  IDENT {
                    printf("<functionCall '%s'>\n", yytext);
                    stack_push(FunctionCall_new_funcCall(yytext, nullToken));
                }
                   OPEN_PAREN ExpressionList? CLOS_PAREN { printf("</functionCall>") }
                   -

ExpressionList  =  Expr                 { printf("Got first argument\n") }
                   (COMMA Expr {printf("Got another argument\n")})*

Sum     = l:Product                     { printf("<sum> '%s'\n", yytext) }
                ( PLUS  r:Product       { printf("+ '%s'\n", yytext); }
                | MINUS r:Product       { printf("- '%s'\n", yytext); }
                )*                      { printf("</sum>\n") }

Product = l:Value                       { printf("<product> '%s'\n", yytext) }
                ( TIMES  r:Value        { printf("* '%s'\n", yytext); }
                | DIV r:Value           { printf("/ '%s'\n", yytext); }
                )*                      { printf("</product>\n") }

Value   = i:NUMBER                      { printf("<value> '%s'\n", yytext); $$=1 }
        | i:STRING_LIT                  { printf("<stringLiteral \"%s\">\n", yytext); }
        | i:IDENT !ASSIGN               { printf("<variableAccess> '%s'\n", yytext); }
        | OPEN_PAREN i:Expr CLOS_PAREN  { printf("<parenthesis>\n"); }
        
NUMBER       = < [0-9]+ >    -
STRING_LIT   = '"' < (!'"' .)* > '"'           - { StringLiteral_new_stringLiteral(yytext, nullToken) }
IDENT        = < [a-zA-Z_]([a-zA-Z0-9_])* >    -
COLON        = ':'           -
COMMA        = ','           -
ASSIGN       = '='           -
PLUS         = '+'           -
MINUS        = '-'           -
TIMES        = '*'           -
DIV          = '/'           -
OPEN_PAREN   = '('           -
CLOS_PAREN   = ')'           -
OPEN_BRACK   = '{'           -
CLOS_BRACK   = '}'           -

-       = [ \t]*
EOL     = '\n' | '\r\n' | '\r' | ';'
WS      = ([ \t] | EOL)*

%%

int Parser_parse() {
  while (yyparse()) {}
  
  return 0;
}
