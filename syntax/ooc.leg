%{
#include <stdio.h>

/* ooc/rock imports */
#include <sdk/lang/BasicTypes-fwd.h>
#include <sdk/io/FileReader.h>

#include <source/rock/middle/Parenthesis-fwd.h>
#include <source/rock/middle/Type-fwd.h>
#include <source/rock/middle/Line-fwd.h>
#include <source/rock/middle/Node-fwd.h>
#include <source/rock/middle/StringLiteral-fwd.h>
#include <source/rock/middle/VariableAccess-fwd.h>
#include <source/rock/middle/IntLiteral-fwd.h>
#include <source/rock/middle/BinaryOp.h> // tight dependency: we use static members
#include <source/rock/middle/FunctionDecl-fwd.h>
#include <source/rock/middle/FunctionCall-fwd.h>

#define YYSTYPE struct _rock_middle__Node*

/* Functions to communicate with rock */
void stack_push(struct _rock_middle__Node *node);
struct _rock_middle__Node *stack_pop(struct _lang__Class *);
void stack_add(struct _rock_middle__Node *node);

/* Current line number */
static int yylineno;

/* Path of the file we're parsing. */
static char* path;
 
/* The stream we're reading from. */
static struct _io__FileReader *stream;

/* Send input to yyparse from codebuf instead of stdin */
/*
#define YY_INPUT(buf, result, max_size) {        \
	int yyc;                                     \
	if (codebuf && *codebuf != '\0')             \
		yyc= *codebuf++;                         \
	else                                         \
		yyc= EOF;                                \
	result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); \
}
*/
#define YY_INPUT(buf, result, max_size) {        \
	int yyc;                                     \
	if (FileReader_hasNext(stream))              \
		yyc= FileReader_read_char(stream);       \
	else                                         \
		yyc= EOF;                                \
	result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1); \
}

%}

Stmt    = WS e:Expr EOL
        | WS d:Decl EOL
        | ( !EOL . )* EOL               { printf("error\n"); }

Expr    = Assignment
        | VariableDecl
        | FunctionCall
        | Sum
        | WS "//" < (!EOL .)* > EOL WS  { printf("skipped comment %s\n", yytext) } Expr?
        
Decl  =  (FunctionDecl | VariableDecl)
                   
FunctionDecl = 
    IDENT {
        printf("<functionDecl '%s'>\n", yytext);
        stack_push(FunctionDecl_new_funcDecl(String_clone(yytext), nullToken));
    }
    COLON "func" -
    Body? 
    - {
        stack_pop(FunctionDecl_class())
    }

Body = 
    OPEN_BRACK
    EOL*
    Line*
    CLOS_BRACK -
                   
Line  =  (WS !EOL e:Expr EOL*) { stack_add(Line_new_line($$)); }

VariableDecl =
    name:IDENT
    COLON
    type:Type {
        printf("Got a variable declaration with name = %s and type = %s\n", name, Node_toString(type));
        $$=VariableDecl_new_vDeclWithAtom(type, Atom_new_name(name), nullToken)
    }
    
Type = IDENT { $$=BaseType_new_baseType(String_clone(yytext), nullToken) }

Assignment =
    l:VariableAccess
    ASSIGN
    r:Expr
    - { $$=BinaryOp_new_binaryOp(l, r, ((struct _rock_middle__OpTypesClass *) OpTypes_class())->ass, nullToken); }
    
VariableAccess =
    name:IDENT
    - { $$=VariableAccess_new_variableAccess(name, nullToken); }

FunctionCall = 
    IDENT {
        stack_push(FunctionCall_new_funcCall(String_clone(yytext), nullToken));
    }
    OPEN_PAREN
    ExpressionList?
    CLOS_PAREN
    - {
        $$ = stack_pop(FunctionCall_class());
    }

ExpressionList  =  Expr                 { stack_add($$) }
                   (COMMA Expr { stack_add($$) })*

Sum     = l:Product
                ( PLUS  r:Product {
                    $$=BinaryOp_new_binaryOp(l, r, ((struct _rock_middle__OpTypesClass *) OpTypes_class())->add, nullToken);
                }
                | MINUS r:Product {
                    $$=BinaryOp_new_binaryOp(l, r, ((struct _rock_middle__OpTypesClass *) OpTypes_class())->sub, nullToken);
                }
                )*

Product = l:Value
                ( TIMES  r:Value {
                    $$=BinaryOp_new_binaryOp(l, r, ((struct _rock_middle__OpTypesClass *) OpTypes_class())->mul, nullToken);
                }
                | DIV r:Value {
                    $$=BinaryOp_new_binaryOp(l, r, ((struct _rock_middle__OpTypesClass *) OpTypes_class())->div, nullToken);
                }
                )*

Value   = i:NUMBER
        | i:STRING_LIT
        | name:IDENT !ASSIGN {
            $$=VariableAccess_new_variableAccess(name, nullToken)
        }
        | OPEN_PAREN inner:Expr CLOS_PAREN {
            $$=Parenthesis_new_parenthesis(inner, nullToken)
        }
        
NUMBER       = < [0-9]+ >                      - { $$=IntLiteral_new_intLiteral(atoll(yytext), nullToken); }
STRING_LIT   = '"' < (!'"' .)* > '"'           - { $$=StringLiteral_new_stringLiteral(String_clone(yytext), nullToken); }
IDENT        = < [a-zA-Z_]([a-zA-Z0-9_])* >    - { $$=String_clone(yytext); }
COLON        = ':'           -
COMMA        = ','           -
ASSIGN       = '='           -
PLUS         = '+'           -
MINUS        = '-'           -
TIMES        = '*'           -
DIV          = '/'           -
OPEN_PAREN   = '('           -
CLOS_PAREN   = ')'           -
OPEN_BRACK   = '{'           -
CLOS_BRACK   = '}'           -

-       = [ \t]*
EOL     = ('\n' | '\r\n' | '\r') { yylineno++ } | ';'
WS      = ([ \t] | EOL)*

%%

int Parser_parse(char *pathArg) {
    /* Parse code */
    path = pathArg;
    stream = FileReader_new_withName(path);
    yylineno = 1;
    while (yyparse()) {}
    return 0;
}
